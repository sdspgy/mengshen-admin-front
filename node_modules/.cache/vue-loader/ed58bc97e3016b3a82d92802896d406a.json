{"remainingRequest":"/Users/hoolai/Documents/tyz/workspace-ws/baobao-admin-front/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/hoolai/Documents/tyz/workspace-ws/baobao-admin-front/src/views/my-components/tree-table/Table/Table.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/hoolai/Documents/tyz/workspace-ws/baobao-admin-front/src/views/my-components/tree-table/Table/Table.vue","mtime":1574132205000},{"path":"/Users/hoolai/Documents/tyz/workspace-ws/baobao-admin-front/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/hoolai/Documents/tyz/workspace-ws/baobao-admin-front/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/hoolai/Documents/tyz/workspace-ws/baobao-admin-front/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/hoolai/Documents/tyz/workspace-ws/baobao-admin-front/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/hoolai/Documents/tyz/workspace-ws/baobao-admin-front/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport TableHeader from './TableHeader';\nimport TableBody from './TableBody';\nimport TableFooter from './TableFooter';\nimport { mixins, scrollBarWidth as getSbw } from './utils';\n\n/* eslint-disable no-underscore-dangle */\n/* eslint-disable no-param-reassign */\n\n// function getBodyData(data, isTreeType, childrenProp, isFold, level = 1) {\nfunction getBodyData(primaryKey, oldBodyData, data, isTreeType, childrenProp, isFold,parentFold, level = 1) {\n  let bodyData = [];\n  data.forEach((row, index) => {\n    const children = row[childrenProp];\n    const childrenLen = Object.prototype.toString.call(children).slice(8, -1) === 'Array' ? children.length : 0;\n    let curIsFold = isFold;\n    if (isFold && typeof primaryKey === 'string' && Array.isArray(oldBodyData)) {\n      for (let i = 0; i < oldBodyData.length; i++) {\n        const oldRow = oldBodyData[i];\n        if (oldRow[primaryKey] === row[primaryKey]) {\n          if ('_isFold' in oldRow) {\n            curIsFold = oldRow._isFold;\n          }\n          break;\n        }\n      }\n    }\n    bodyData.push({\n      _isHover: false,\n      _isExpanded: false,\n      _isChecked: false,\n      _level: level,\n      // _isHide: isFold ? level !== 1 : false,\n      // _isFold: isFold,\n      _isHide: (level !== 1) ? (isFold && parentFold) : false,\n      _isFold: isFold && curIsFold,\n      _childrenLen: childrenLen,\n      _normalIndex: index + 1,\n      ...row,\n    });\n    if (isTreeType) {\n      if (childrenLen > 0) {\n        // bodyData = bodyData.concat(getBodyData(children, true, childrenProp, isFold, level + 1));\n        bodyData = bodyData.concat(getBodyData(primaryKey, oldBodyData, children, true, childrenProp, isFold, curIsFold, level + 1));\n      }\n    }\n  });\n  return bodyData;\n}\n\nfunction initialState(table, expandKey) {\n  return {\n    bodyHeight: 'auto',\n    firstProp: expandKey || (table.columns[0] && table.columns[0].key),\n    // bodyData: getBodyData(table.data, table.treeType, table.childrenProp, table.isFold),\n    bodyData: getBodyData(table.primaryKey, table.bodyData, table.data, table.treeType, table.childrenProp, table.isFold, false),\n  };\n}\n\nfunction initialColumns(table, clientWidth) {\n  let columnsWidth = 0;\n  const minWidthColumns = [];\n  const otherColumns = [];\n  const columns = table.columns.concat();\n  if (table.expandType) {\n    columns.unshift({\n      width: '50',\n    });\n  }\n  if (table.selectable) {\n    columns.unshift({\n      width: '50',\n    });\n  }\n  if (table.showIndex) {\n    columns.unshift({\n      width: '50px',\n      key: '_normalIndex',\n      title: table.indexText,\n    });\n  }\n  columns.forEach((column, index) => {\n    let width = '';\n    let minWidth = '';\n    if (!column.width) {\n      if (column.minWidth) {\n        minWidth = typeof column.minWidth === 'number' ? column.minWidth : parseInt(column.minWidth, 10);\n      } else {\n        minWidth = 80;\n      }\n      minWidthColumns.push({\n        ...column,\n        minWidth,\n        _index: index,\n      });\n    } else {\n      width = typeof column.width === 'number' ? column.width : parseInt(column.width, 10);\n      otherColumns.push({\n        ...column,\n        width,\n        _index: index,\n      });\n    }\n    columnsWidth += minWidth || width;\n  });\n  const scrollBarWidth = getSbw();\n  const totalWidth = columnsWidth + scrollBarWidth;\n  const isScrollX = totalWidth > clientWidth;\n  if (!isScrollX) {\n    const extraWidth = clientWidth - totalWidth;\n    const averageExtraWidth = Math.floor(extraWidth / minWidthColumns.length);\n    minWidthColumns.forEach((column) => {\n      column.computedWidth = column.minWidth + averageExtraWidth;\n    });\n  }\n  const tableColumns = otherColumns.concat(minWidthColumns);\n  tableColumns.sort((a, b) => a._index - b._index);\n  return tableColumns;\n}\n\nexport default {\n  name: 'TreeTable',\n  mixins: [mixins],\n  components: {\n    TableHeader,\n    TableBody,\n    TableFooter,\n  },\n  props: {\n    data: {\n      type: Array,\n      default: () => [],\n    },\n    columns: {\n      type: Array,\n      default: () => [],\n    },\n    loading: {\n      type: Boolean,\n      default: false,\n    },\n    maxHeight: {\n      type: [String, Number],\n      default: 'auto',\n    },\n    stripe: {\n      type: Boolean,\n      default: false,\n    },\n    border: {\n      type: Boolean,\n      default: false,\n    },\n    treeType: {\n      type: Boolean,\n      default: true,\n    },\n    childrenProp: {\n      type: String,\n      default: 'children',\n    },\n    isFold: {\n      type: Boolean,\n      default: true,\n    },\n    expandType: {\n      type: Boolean,\n      default: true,\n    },\n    selectable: {\n      type: Boolean,\n      default: true,\n    },\n    selectType: {\n      type: String,\n      default: 'checkbox',\n    },\n    emptyText: {\n      type: String,\n      default: '暂无数据',\n    },\n    showHeader: {\n      type: Boolean,\n      default: true,\n    },\n    showIndex: {\n      type: Boolean,\n      default: false,\n    },\n    indexText: {\n      type: String,\n      default: '#',\n    },\n    showSummary: {\n      type: Boolean,\n      default: false,\n    },\n    sumText: {\n      type: String,\n      default: '合计',\n    },\n    primaryKey: String,\n    summaryMethod: Function,\n    showRowHover: {\n      type: Boolean,\n      default: true,\n    },\n    rowKey: Function,\n    rowClassName: [String, Function],\n    cellClassName: [String, Function],\n    rowStyle: [Object, Function],\n    cellStyle: [Object, Function],\n    expandKey: String,\n  },\n  data() {\n    return {\n      computedWidth: '',\n      computedHeight: '',\n      tableColumns: [],\n      ...initialState(this, this.expandKey),\n    };\n  },\n  computed: {\n    bodyWrapperStyle() {\n      return {\n        height: this.bodyHeight,\n      };\n    },\n    tableClass() {\n      return {\n        [`${this.prefixCls}--border`]: this.border,\n      };\n    },\n    bodyClass() {\n      return {\n        [`${this.prefixCls}--stripe`]: this.stripe,\n      };\n    },\n  },\n  methods: {\n    handleEvent(type, $event) {\n      this.validateType(type, ['header', 'body', 'footer'], 'handleEvent');\n      const eventType = $event.type;\n      if (eventType === 'scroll') {\n        this.$refs['header-wrapper'].scrollLeft = $event.target.scrollLeft;\n        this.$refs['footer-wrapper'].scrollLeft = $event.target.scrollLeft;\n      }\n      if (eventType === 'mousewheel') {\n        const deltaX = $event.deltaX;\n        const $body = this.$refs['body-wrapper'];\n        if (deltaX > 0) {\n          $body.scrollLeft += 10;\n        } else {\n          $body.scrollLeft -= 10;\n        }\n      }\n      return this.$emit(`${type}-${eventType}`, $event);\n    },\n    // computedWidth, computedHeight, tableColumns\n    measure() {\n      this.$nextTick(() => {\n        const { clientWidth, clientHeight } = this.$el;\n        this.computedWidth = clientWidth + 2;\n        this.computedHeight = clientHeight + 2;\n\n        const maxHeight = parseInt(this.maxHeight, 10);\n        if (this.maxHeight !== 'auto' && this.computedHeight > maxHeight) {\n          this.bodyHeight = `${maxHeight - 83}px`;\n        }\n        this.tableColumns = initialColumns(this, clientWidth);\n      });\n    },\n    getCheckedProp(key = 'index') {\n      if (!this.selectable) {\n        return [];\n      }\n      const checkedIndexs = [];\n      this.bodyData.forEach((item, index) => {\n        if (item._isChecked) {\n          if (key === 'index') {\n            checkedIndexs.push(index);\n          } else {\n            checkedIndexs.push(item[key]);\n          }\n        }\n      });\n      return checkedIndexs;\n    },\n  },\n  watch: {\n    $props: {\n      deep: true,\n      handler() {\n        Object.assign(this.$data, initialState(this, this.expandKey));\n      },\n    },\n  },\n  updated() {\n    this.measure();\n  },\n  mounted() {\n    this.measure();\n    window.addEventListener('resize', this.measure);\n  },\n  beforeDestroy() {\n    window.removeEventListener('resize', this.measure);\n  },\n};\n",null]}